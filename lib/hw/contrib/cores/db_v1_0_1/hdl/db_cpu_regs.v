//
// Copyright (c) 2015 University of Cambridge
// Modified by Yuta Tokusashi
// All rights reserved.
//
//
//  File:
//        db_cpu_regs.v
//
//  Module:
//        db_cpu_regs
//
//  Description:
//        This file is automatically generated with the registers towards the CPU/Software
//
// This software was developed by
// Stanford University and the University of Cambridge Computer Laboratory
// under National Science Foundation under Grant No. CNS-0855268,
// the University of Cambridge Computer Laboratory under EPSRC INTERNET Project EP/H040536/1 and
// by the University of Cambridge Computer Laboratory under DARPA/AFRL contract FA8750-11-C-0249 ("MRC2"), 
// as part of the DARPA MRC research programme.
//
// @NETFPGA_LICENSE_HEADER_START@
//
// Licensed to NetFPGA C.I.C. (NetFPGA) under one or more contributor
// license agreements.  See the NOTICE file distributed with this work for
// additional information regarding copyright ownership.  NetFPGA licenses this
// file to you under the NetFPGA Hardware-Software License, Version 1.0 (the
// "License"); you may not use this file except in compliance with the
// License.  You may obtain a copy of the License at:
//
//   http://www.netfpga-cic.org
//
// Unless required by applicable law or agreed to in writing, Work distributed
// under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR
// CONDITIONS OF ANY KIND, either express or implied.  See the License for the
// specific language governing permissions and limitations under the License.
//
// @NETFPGA_LICENSE_HEADER_END@
//
`timescale 1ns/1ns

//`ifdef SIMULATION_DEBUG
//`include "5PE_db_cpu_regs_defines.v"
//`else
`include "db_cpu_regs_defines.v"
//`endif /*SIMULATION_DEBUG*/
module db_cpu_regs #
(
parameter C_BASE_ADDRESS        = 32'h00000000,
parameter C_S_AXI_DATA_WIDTH    = 32,
parameter C_S_AXI_ADDR_WIDTH    = 32
)
(
    // General ports
    input       clk,
    input       resetn,
    // Global Registers
    input       cpu_resetn_soft,
    output reg  resetn_soft,
    output reg  resetn_sync,

   // Register ports
    input      [`REG_ID_BITS]        id_reg,
    input      [`REG_VERSION_BITS]   version_reg,
    output reg [`REG_RESET_BITS]     reset_reg,
    input      [`REG_FLIP_BITS]      ip2cpu_flip_reg,
    output reg [`REG_FLIP_BITS]      cpu2ip_flip_reg,
    input      [`REG_DEBUG_BITS]     ip2cpu_debug_reg,
    output reg [`REG_DEBUG_BITS]     cpu2ip_debug_reg,
    input      [`REG_PKTIN_BITS]     pktin_reg,
    output reg                       pktin_reg_clear,
    input      [`REG_PKTOUT_BITS]    pktout_reg,
    output reg                       pktout_reg_clear,
	input      [`REG_IPADDR_BITS]    ip2cpu_local_ipaddr_reg,
	output reg [`REG_IPADDR_BITS]    cpu2ip_local_ipaddr_reg,
	input      [`REG_LAKEON_BITS]    ip2cpu_lakeon_reg,
	output reg [`REG_LAKEON_BITS]    cpu2ip_lakeon_reg,
	input      [`REG_KVSPORT_BITS]   ip2cpu_kvs_uport_reg,
	output reg [`REG_KVSPORT_BITS]   cpu2ip_kvs_uport_reg,
	input      [`REG_MODE_BITS]      ip2cpu_mode_reg,
	output reg [`REG_MODE_BITS]      cpu2ip_mode_reg,
	input      [`REG_L1HIT_BITS]     queries_l1hit_reg,
	input      [`REG_L1MISS_BITS]    queries_l1miss_reg,
	output reg                       querieshit_reg_clear,
	output reg                       queriesmiss_reg_clear,
	input      [`REG_PKTIN_BITS]     p0_pktin,
	input      [`REG_PKTIN_BITS]     p0_pktout,
	input      [`REG_PKTIN_BITS]     p1_pktin,
	input      [`REG_PKTIN_BITS]     p1_pktout,
	input      [`REG_PKTIN_BITS]     p2_pktin,
	input      [`REG_PKTIN_BITS]     p2_pktout,
	input      [`REG_PKTIN_BITS]     p3_pktin,
	input      [`REG_PKTIN_BITS]     p3_pktout,
	input      [`REG_PKTIN_BITS]     p4_pktin,
	input      [`REG_PKTIN_BITS]     p4_pktout,
	//input      [`REG_PKTIN_BITS]     p3_pktin,
	//input      [`REG_PKTIN_BITS]     p3_pktout,
	//input      [`REG_PKTIN_BITS]     p4_pktin,
	//input      [`REG_PKTIN_BITS]     p4_pktout,
	//input      [`REG_PKTIN_BITS]     p5_pktin,
	//input      [`REG_PKTIN_BITS]     p5_pktout,
	//input      [`REG_PKTIN_BITS]     p6_pktin,
	//input      [`REG_PKTIN_BITS]     p6_pktout,
	//input      [`REG_PKTIN_BITS]     p7_pktin,
	//input      [`REG_PKTIN_BITS]     p7_pktout,
	//input      [`REG_PKTIN_BITS]     p8_pktin,
	//input      [`REG_PKTIN_BITS]     p8_pktout,
	//input      [`REG_PKTIN_BITS]     p9_pktin,
	//input      [`REG_PKTIN_BITS]     p9_pktout,
	//input      [`REG_PKTIN_BITS]     p10_pktin,
	//input      [`REG_PKTIN_BITS]     p10_pktout,
	//input      [`REG_PKTIN_BITS]     p11_pktin,
	//input      [`REG_PKTIN_BITS]     p11_pktout,
	//input      [`REG_PKTIN_BITS]     p12_pktin,
	//input      [`REG_PKTIN_BITS]     p12_pktout,
	//input      [`REG_PKTIN_BITS]     p13_pktin,
	//input      [`REG_PKTIN_BITS]     p13_pktout,
	//input      [`REG_PKTIN_BITS]     p14_pktin,
	//input      [`REG_PKTIN_BITS]     p14_pktout,
	//input      [`REG_PKTIN_BITS]     p15_pktin,
	//input      [`REG_PKTIN_BITS]     p15_pktout,
	input      [`REG_DRAM_BITS]      dram_access,
	input      [`REG_DRAMRD_BITS]    dram_read,
	input      [`REG_DRAM_BITS]      dram_access_in,
	input      [`REG_DRAM_BITS]      dram_access_out,
	input      [`REG_DRAM_BITS]      dramA_scache_all,
	input      [`REG_DRAM_BITS]      dramA_scache_hit,

	input      [`REG_P0DEBUG_BITS]   p0_debug,
	input      [`REG_P1DEBUG_BITS]   p1_debug,
	input      [`REG_P2DEBUG_BITS]   p2_debug,
	input      [`REG_P0CHUNK_BITS]   p0_chunk,
	input      [`REG_P1CHUNK_BITS]   p1_chunk,
	input      [`REG_P2CHUNK_BITS]   p2_chunk,
	input      [`REG_SRAM0WR_BITS]   sram0_wrcmd,
	input      [`REG_SRAM0RD_BITS]   sram0_rdcmd,
	input      [`REG_SRAM1WR_BITS]   sram1_wrcmd,
	input      [`REG_SRAM1RD_BITS]   sram1_rdcmd,
	input      [`REG_SRAMIN_BITS]    sram_incnt,
	input      [`REG_SRAMOUT_BITS]   sram_outcnt,
	input      [`REG_STATS_BITS]     stat_set_cnt,
	input      [`REG_STATG_BITS]     stat_get_cnt,
	input      [`REG_STATD_BITS]     stat_del_cnt,

	input      [`REG_P0ERR_BITS]     pe0_errpkt,
	input      [`REG_P1ERR_BITS]     pe1_errpkt,
	input      [`REG_P2ERR_BITS]     pe2_errpkt,
	input      [`REG_LUTIN_BITS]     lut_access_in,
	input      [`REG_LUTOUT_BITS]    lut_access_out,
	output reg [`REG_PEEN_BITS]      cpu2ip_pes_enable_reg,
	input      [`REG_PEEN_BITS]      ip2cpu_pes_enable_reg,
	output reg [`REG_SCACHEEN_BITS]      cpu2ip_scache_enable_reg,
	input      [`REG_SCACHEEN_BITS]      ip2cpu_scache_enable_reg,
	output reg [`REG_SCACHEEN_BITS]      cpu2ip_clockgate_enable_reg,
	input      [`REG_SCACHEEN_BITS]      ip2cpu_clockgate_enable_reg,


    // AXI Lite ports
    input                                     S_AXI_ACLK,
    input                                     S_AXI_ARESETN,
    input      [C_S_AXI_ADDR_WIDTH-1 : 0]     S_AXI_AWADDR,
    input                                     S_AXI_AWVALID,
    input      [C_S_AXI_DATA_WIDTH-1 : 0]     S_AXI_WDATA,
    input      [C_S_AXI_DATA_WIDTH/8-1 : 0]   S_AXI_WSTRB,
    input                                     S_AXI_WVALID,
    input                                     S_AXI_BREADY,
    input      [C_S_AXI_ADDR_WIDTH-1 : 0]     S_AXI_ARADDR,
    input                                     S_AXI_ARVALID,
    input                                     S_AXI_RREADY,
    output                                    S_AXI_ARREADY,
    output     [C_S_AXI_DATA_WIDTH-1 : 0]     S_AXI_RDATA,
    output     [1 : 0]                        S_AXI_RRESP,
    output                                    S_AXI_RVALID,
    output                                    S_AXI_WREADY,
    output     [1 :0]                         S_AXI_BRESP,
    output                                    S_AXI_BVALID,
    output                                    S_AXI_AWREADY

);

    // AXI4LITE signals
    reg [C_S_AXI_ADDR_WIDTH-1 : 0]      axi_awaddr;
    reg                                 axi_awready;
    reg                                 axi_wready;
    reg [1 : 0]                         axi_bresp;
    reg                                 axi_bvalid;
    reg [C_S_AXI_ADDR_WIDTH-1 : 0]      axi_araddr;
    reg                                 axi_arready;
    reg [C_S_AXI_DATA_WIDTH-1 : 0]      axi_rdata;
    reg [1 : 0]                         axi_rresp;
    reg                                 axi_rvalid;

    reg                                 resetn_sync_d;
    wire                                reg_rden;
    wire                                reg_wren;
    reg [C_S_AXI_DATA_WIDTH-1:0]        reg_data_out;
    integer                             byte_index;
    reg                                 pktin_reg_clear_d;
    reg                                 pktout_reg_clear_d;
    reg                                 querieshit_reg_clear_d;
    reg                                 queriesmiss_reg_clear_d;

    // I/O Connections assignments
    assign S_AXI_AWREADY    = axi_awready;
    assign S_AXI_WREADY     = axi_wready;
    assign S_AXI_BRESP      = axi_bresp;
    assign S_AXI_BVALID     = axi_bvalid;
    assign S_AXI_ARREADY    = axi_arready;
    assign S_AXI_RDATA      = axi_rdata;
    assign S_AXI_RRESP      = axi_rresp;
    assign S_AXI_RVALID     = axi_rvalid;


    //Sample reset (not mandatory, but good practice)
    always @ (posedge clk) begin
        if (~resetn) begin
            resetn_sync_d  <=  1'b0;
            resetn_sync    <=  1'b0;
        end
        else begin
            resetn_sync_d  <=  resetn;
            resetn_sync    <=  resetn_sync_d;
        end
    end


    //global registers, sampling
    always @(posedge clk) resetn_soft <= #1 cpu_resetn_soft;

    // Implement axi_awready generation

    always @( posedge S_AXI_ACLK )
    begin
      if ( S_AXI_ARESETN == 1'b0 )
        begin
          axi_awready <= 1'b0;
        end
      else
        begin
          if (~axi_awready && S_AXI_AWVALID && S_AXI_WVALID)
            begin
              // slave is ready to accept write address when
              // there is a valid write address and write data
              // on the write address and data bus. This design
              // expects no outstanding transactions.
              axi_awready <= 1'b1;
            end
          else
            begin
              axi_awready <= 1'b0;
            end
        end
    end

    // Implement axi_awaddr latching

    always @( posedge S_AXI_ACLK )
    begin
      if ( S_AXI_ARESETN == 1'b0 )
        begin
          axi_awaddr <= 0;
        end
      else
        begin
          if (~axi_awready && S_AXI_AWVALID && S_AXI_WVALID)
            begin
              // Write Address latching
              axi_awaddr <= S_AXI_AWADDR ^ C_BASE_ADDRESS;
            end
        end
    end

    // Implement axi_wready generation

    always @( posedge S_AXI_ACLK )
    begin
      if ( S_AXI_ARESETN == 1'b0 )
        begin
          axi_wready <= 1'b0;
        end
      else
        begin
          if (~axi_wready && S_AXI_WVALID && S_AXI_AWVALID)
            begin
              // slave is ready to accept write data when
              // there is a valid write address and write data
              // on the write address and data bus. This design
              // expects no outstanding transactions.
              axi_wready <= 1'b1;
            end
          else
            begin
              axi_wready <= 1'b0;
            end
        end
    end

    // Implement write response logic generation

    always @( posedge S_AXI_ACLK )
    begin
      if ( S_AXI_ARESETN == 1'b0 )
        begin
          axi_bvalid  <= 0;
          axi_bresp   <= 2'b0;
        end
      else
        begin
          if (axi_awready && S_AXI_AWVALID && ~axi_bvalid && axi_wready && S_AXI_WVALID)
            begin
              // indicates a valid write response is available
              axi_bvalid <= 1'b1;
              axi_bresp  <= 2'b0; // OKAY response
            end                   // work error responses in future
          else
            begin
              if (S_AXI_BREADY && axi_bvalid)
                //check if bready is asserted while bvalid is high)
                //(there is a possibility that bready is always asserted high)
                begin
                  axi_bvalid <= 1'b0;
                end
            end
        end
    end

    // Implement axi_arready generation

    always @( posedge S_AXI_ACLK )
    begin
      if ( S_AXI_ARESETN == 1'b0 )
        begin
          axi_arready <= 1'b0;
          axi_araddr  <= 32'b0;
        end
      else
        begin
          if (~axi_arready && S_AXI_ARVALID)
            begin
              // indicates that the slave has acceped the valid read address
              // Read address latching
              axi_arready <= 1'b1;
              axi_araddr  <= S_AXI_ARADDR ^ C_BASE_ADDRESS;
            end
          else
            begin
              axi_arready <= 1'b0;
            end
        end
    end


    // Implement axi_rvalid generation

    always @( posedge S_AXI_ACLK )
    begin
      if ( S_AXI_ARESETN == 1'b0 )
        begin
          axi_rvalid <= 0;
          axi_rresp  <= 0;
        end
      else
        begin
          if (axi_arready && S_AXI_ARVALID && ~axi_rvalid)
            begin
              // Valid read data is available at the read data bus
              axi_rvalid <= 1'b1;
              axi_rresp  <= 2'b0; // OKAY response
            end
          else if (axi_rvalid && S_AXI_RREADY)
            begin
              // Read data is accepted by the master
              axi_rvalid <= 1'b0;
            end
        end
    end


    // Implement memory mapped register select and write logic generation

    assign reg_wren = axi_wready && S_AXI_WVALID && axi_awready && S_AXI_AWVALID;

//////////////////////////////////////////////////////////////
// write registers
//////////////////////////////////////////////////////////////


//Write only register, clear on write (i.e. event)
    always @(posedge clk) begin
        if (!resetn_sync) begin
            reset_reg        <= #1 `REG_RESET_DEFAULT;
        end
        else begin
            if (reg_wren) begin
                case (axi_awaddr)
                    //Reset Register
                        `REG_RESET_ADDR : begin
                                for ( byte_index = 0; byte_index <= (`REG_RESET_WIDTH/8-1); byte_index = byte_index +1)
                                    if (S_AXI_WSTRB[byte_index] == 1) begin
                                        reset_reg[byte_index*8 +: 8] <=  S_AXI_WDATA[byte_index*8 +: 8];
                                    end
                        end
                endcase
            end
            else begin
                reset_reg        <= #1 `REG_RESET_DEFAULT;
            end
        end
    end

//R/W register, not cleared
    always @(posedge clk) begin
        if (!resetn_sync) begin

            cpu2ip_flip_reg         <= #1 `REG_FLIP_DEFAULT;
            cpu2ip_debug_reg        <= #1 `REG_DEBUG_DEFAULT;
            cpu2ip_local_ipaddr_reg <= #1 `REG_IPADDR_DEFAULT;
            cpu2ip_kvs_uport_reg    <= #1 `REG_KVSPORT_DEFAULT;
            cpu2ip_mode_reg         <= #1 `REG_MODE_DEFAULT;
            cpu2ip_pes_enable_reg   <= #1 `REG_PEEN_DEFAULT;
            cpu2ip_scache_enable_reg     <= #1 `REG_SCACHEEN_DEFAULT;
            cpu2ip_clockgate_enable_reg  <= #1 `REG_CLOCKGATE_DEFAULT;
			cpu2ip_lakeon_reg            <= #1 `REG_LAKEON_DEFAULT;
        end
        else begin
           if (reg_wren) //write event
            case (axi_awaddr)
            //Flip Register
                `REG_FLIP_ADDR : begin
                    for ( byte_index = 0; byte_index <= (`REG_FLIP_WIDTH/8-1); byte_index = byte_index +1)
                        if (S_AXI_WSTRB[byte_index] == 1) begin
                            cpu2ip_flip_reg[byte_index*8 +: 8] <=  S_AXI_WDATA[byte_index*8 +: 8]; //dynamic register;
                        end
                end
            //Debug Register
                `REG_DEBUG_ADDR : begin
                    for ( byte_index = 0; byte_index <= (`REG_DEBUG_WIDTH/8-1); byte_index = byte_index +1)
                        if (S_AXI_WSTRB[byte_index] == 1) begin
                            cpu2ip_debug_reg[byte_index*8 +: 8] <=  S_AXI_WDATA[byte_index*8 +: 8]; //dynamic register;
                        end
                end
                `REG_IPADDR_ADDR : begin
                    for ( byte_index = 0; byte_index <= (`REG_IPADDR_WIDTH/8-1); byte_index = byte_index +1)
                        if (S_AXI_WSTRB[byte_index] == 1) begin
                            cpu2ip_local_ipaddr_reg[byte_index*8 +: 8] <=  S_AXI_WDATA[byte_index*8 +: 8]; //dynamic register;
                        end
                end
                `REG_KVSPORT_ADDR : begin
                    for ( byte_index = 0; byte_index <= (`REG_KVSPORT_WIDTH/8-1); byte_index = byte_index +1)
                        if (S_AXI_WSTRB[byte_index] == 1) begin
                            cpu2ip_kvs_uport_reg[byte_index*8 +: 8] <=  S_AXI_WDATA[byte_index*8 +: 8]; //dynamic register;
                        end
                end
                `REG_MODE_ADDR : begin
                    for ( byte_index = 0; byte_index <= (`REG_MODE_WIDTH/8-1); byte_index = byte_index +1)
                        if (S_AXI_WSTRB[byte_index] == 1) begin
                            cpu2ip_mode_reg[byte_index*8 +: 8] <=  S_AXI_WDATA[byte_index*8 +: 8]; //dynamic register;
                        end
                end
                `REG_PEEN_ADDR : begin
                    for ( byte_index = 0; byte_index <= (`REG_PEEN_WIDTH/8-1); byte_index = byte_index +1)
                        if (S_AXI_WSTRB[byte_index] == 1) begin
                            cpu2ip_pes_enable_reg[byte_index*8 +: 8] <=  S_AXI_WDATA[byte_index*8 +: 8]; //dynamic register;
                        end
                end
                `REG_SCACHEEN_ADDR : begin
                    for ( byte_index = 0; byte_index <= (`REG_SCACHEEN_WIDTH/8-1); byte_index = byte_index +1)
                        if (S_AXI_WSTRB[byte_index] == 1) begin
                            cpu2ip_scache_enable_reg[byte_index*8 +: 8] <=  S_AXI_WDATA[byte_index*8 +: 8]; //dynamic register;
                        end
                end
                `REG_CLOCKGATE_ADDR : begin
                    for ( byte_index = 0; byte_index <= (`REG_CLOCKGATE_WIDTH/8-1); byte_index = byte_index +1)
                        if (S_AXI_WSTRB[byte_index] == 1) begin
                            cpu2ip_clockgate_enable_reg[byte_index*8 +: 8] <=  S_AXI_WDATA[byte_index*8 +: 8]; //dynamic register;
                        end
                end
                `REG_LAKEON_ADDR : begin
                    for ( byte_index = 0; byte_index <= (`REG_LAKEON_WIDTH/8-1); byte_index = byte_index +1)
                        if (S_AXI_WSTRB[byte_index] == 1) begin
                            cpu2ip_lakeon_reg[byte_index*8 +: 8] <=  S_AXI_WDATA[byte_index*8 +: 8]; //dynamic register;
                        end
                end
                default: begin
                end

            endcase
        end
    end



/////////////////////////
//// end of write
/////////////////////////

    // Implement memory mapped register select and read logic generation
    // Slave register read enable is asserted when valid address is available
    // and the slave is ready to accept the read address.

    // reg_rden control logic
    // temperary no extra logic here
    assign reg_rden = axi_arready & S_AXI_ARVALID & ~axi_rvalid;

    always @(*)
    begin

        case ( axi_araddr /*S_AXI_ARADDR ^ C_BASE_ADDRESS*/)
            //Id Register
            `REG_ID_ADDR : begin
                reg_data_out [`REG_ID_BITS] =  id_reg;
            end
            //Version Register
            `REG_VERSION_ADDR : begin
                reg_data_out [`REG_VERSION_BITS] =  version_reg;
            end
            //Flip Register
            `REG_FLIP_ADDR : begin
                reg_data_out [`REG_FLIP_BITS] =  ip2cpu_flip_reg;
            end
            //Debug Register
            `REG_DEBUG_ADDR : begin
                reg_data_out [`REG_DEBUG_BITS] =  ip2cpu_debug_reg;
            end
            `REG_IPADDR_ADDR : begin
                reg_data_out [`REG_DEBUG_BITS] =  ip2cpu_local_ipaddr_reg;
            end
            `REG_KVSPORT_ADDR : begin
                reg_data_out [31:0] =  {16'd0, ip2cpu_kvs_uport_reg};
            end
            `REG_MODE_ADDR : begin
                reg_data_out [31:0] =  {24'd0, ip2cpu_mode_reg};
            end
            //Pktin Register
            `REG_PKTIN_ADDR : begin
                reg_data_out [`REG_PKTIN_BITS] =  pktin_reg;
            end
            //Pktout Register
            `REG_PKTOUT_ADDR : begin
                reg_data_out [`REG_PKTOUT_BITS] =  pktout_reg;
            end
            //KVS L1 HIT
            `REG_L1HIT_ADDR : begin
                reg_data_out [`REG_L1HIT_BITS] =  queries_l1hit_reg;
            end
            //KVS L1 MISS
            `REG_L1MISS_ADDR : begin
                reg_data_out [`REG_L1MISS_BITS] =  queries_l1miss_reg;
            end
            //Pktin Register
            `REG_P0PKTIN_ADDR : begin
                reg_data_out [`REG_P0PKTIN_BITS] =  p0_pktin;
            end
            //Pktin Register
            `REG_P0PKTOUT_ADDR : begin
                reg_data_out [`REG_P0PKTOUT_BITS] =  p0_pktout;
            end
            //Pktin Register
            `REG_P1PKTIN_ADDR : begin
                reg_data_out [`REG_P1PKTIN_BITS] =  p1_pktin;
            end
            //Pktin Register
            `REG_P1PKTOUT_ADDR : begin
                reg_data_out [`REG_P1PKTOUT_BITS] =  p1_pktout;
            end
            //Pktin Register
            `REG_P2PKTIN_ADDR : begin
                reg_data_out [`REG_P2PKTIN_BITS] =  p2_pktin;
            end
            //Pktin Register
            `REG_P2PKTOUT_ADDR : begin
                reg_data_out [`REG_P2PKTOUT_BITS] =  p2_pktout;
            end
            //Pktin Register
            `REG_P0DEBUG_ADDR : begin
                reg_data_out [`REG_P0DEBUG_BITS] =  p0_debug;
            end
            //Pktin Register
            `REG_P1DEBUG_ADDR : begin
                reg_data_out [`REG_P1DEBUG_BITS] =  p1_debug;
            end
            //Pktin Register
            `REG_P2DEBUG_ADDR : begin
                reg_data_out [`REG_P2DEBUG_BITS] =  p2_debug;
            end
            //Pktin Register
            `REG_DRAM_ADDR : begin
                reg_data_out [`REG_DRAM_BITS] =  dram_access;
            end
            //Pktin Register
            `REG_DRAMIN_ADDR : begin
                reg_data_out [`REG_DRAMIN_BITS] =  dram_access_in;
            end
            //Pktin Register
            `REG_DRAMOUT_ADDR : begin
                reg_data_out [`REG_DRAMOUT_BITS] =  dram_access_out;
            end
            `REG_DRAMCACHEALL_ADDR : begin
                reg_data_out [`REG_DRAMCACHEALL_BITS] =  dramA_scache_all;
            end
            `REG_DRAMCACHEHIT_ADDR : begin
                reg_data_out [`REG_DRAMCACHEHIT_BITS] =  dramA_scache_hit;
            end
            // SRAM 0 WR DEBUG
            `REG_SRAM0WR_ADDR : begin
                reg_data_out [`REG_SRAM0WR_BITS] =  sram0_wrcmd;
            end
            // SRAM 0 RD DEBUG
            `REG_SRAM0RD_ADDR : begin
                reg_data_out [`REG_SRAM0RD_BITS] =  sram0_rdcmd;
            end
            // SRAM 1 WR DEBUG
            `REG_SRAM1WR_ADDR : begin
                reg_data_out [`REG_SRAM1WR_BITS] =  sram1_wrcmd;
            end
            // SRAM 1 WR DEBUG
            `REG_SRAM1RD_ADDR : begin
                reg_data_out [`REG_SRAM1RD_BITS] =  sram1_rdcmd;
            end
            // STAT
            `REG_STATS_ADDR : begin
                reg_data_out [`REG_STATS_BITS] =  stat_set_cnt;
            end
            // STAT
            `REG_STATG_ADDR : begin
                reg_data_out [`REG_STATG_BITS] =  stat_get_cnt;
            end
            // STAT
            `REG_STATD_ADDR : begin
                reg_data_out [`REG_STATD_BITS] =  stat_del_cnt;
            end
            // P0 CHUNK ADDR
            `REG_P0CHUNK_ADDR : begin
                reg_data_out [`REG_P0CHUNK_BITS] =  p0_chunk;
            end
            // P1 CHUNK ADDR
            `REG_P1CHUNK_ADDR : begin
                reg_data_out [`REG_P1CHUNK_BITS] =  p1_chunk;
            end
            // P2 CHUNK ADDR
            `REG_P2CHUNK_ADDR : begin
                reg_data_out [`REG_P2CHUNK_BITS] =  p2_chunk;
            end
            // P0 ERRPKT ADDR
            `REG_P0ERR_ADDR : begin
                reg_data_out [`REG_P0ERR_BITS] =  pe0_errpkt;
            end
            // P1 ERRPKT ADDR
            `REG_P1ERR_ADDR : begin
                reg_data_out [`REG_P1ERR_BITS] =  pe1_errpkt;
            end
            // P2 ERRPKT ADDR
            `REG_P2ERR_ADDR : begin
                reg_data_out [`REG_P2ERR_BITS] =  pe2_errpkt;
            end
            //Pktin Register
            `REG_DRAMRD_ADDR : begin
                reg_data_out [`REG_DRAMRD_BITS] =  dram_read;
            end
            //Pktin Register
            `REG_SRAMIN_ADDR : begin
                reg_data_out [`REG_SRAMIN_BITS] =  sram_incnt;
            end
            //Pktin Register
            `REG_SRAMOUT_ADDR : begin
                reg_data_out [`REG_SRAMOUT_BITS] = sram_outcnt;
            end
            //Pktin Register
            `REG_LUTIN_ADDR : begin
                reg_data_out [`REG_SRAMOUT_BITS] = lut_access_in;
            end
            //Pktin Register
            `REG_LUTOUT_ADDR : begin
                reg_data_out [`REG_SRAMOUT_BITS] = lut_access_out;
            end
            //Pktout Register
            `REG_PEEN_ADDR : begin
                reg_data_out [31:0]    =  {16'd0, ip2cpu_pes_enable_reg};
            end
            //Pktin Register
            `REG_P3PKTIN_ADDR : begin
                reg_data_out [`REG_P3PKTIN_BITS] =  p3_pktin;
            end
            //Pktout Register
            `REG_P3PKTOUT_ADDR : begin
                reg_data_out [`REG_P3PKTOUT_BITS] =  p3_pktout;
            end
            //Pktin Register
            `REG_P4PKTIN_ADDR : begin
                reg_data_out [`REG_P4PKTIN_BITS] =  p4_pktin;
            end
            //Pktout Register
            `REG_P4PKTOUT_ADDR : begin
                reg_data_out [`REG_P4PKTOUT_BITS] =  p4_pktout;
            end
            `REG_SCACHEEN_ADDR : begin
                reg_data_out [31:0] =  {24'd0, ip2cpu_scache_enable_reg};
            end
            `REG_CLOCKGATE_ADDR : begin
                reg_data_out [31:0] =  {24'd0, ip2cpu_clockgate_enable_reg};
            end
            `REG_LAKEON_ADDR : begin
                reg_data_out [31:0] =  {24'd0, ip2cpu_lakeon_reg};
            end
            ////Pktin Register
            //`REG_P5PKTIN_ADDR : begin
            //    reg_data_out [`REG_P5PKTIN_BITS] =  p5_pktin;
            //end
            ////Pktout Register
            //`REG_P5PKTOUT_ADDR : begin
            //    reg_data_out [`REG_P5PKTOUT_BITS] =  p5_pktout;
            //end
            ////Pktin Register
            //`REG_P6PKTIN_ADDR : begin
            //    reg_data_out [`REG_P6PKTIN_BITS] =  p6_pktin;
            //end
            ////Pktout Register
            //`REG_P6PKTOUT_ADDR : begin
            //    reg_data_out [`REG_P6PKTOUT_BITS] =  p6_pktout;
            //end
            ////Pktin Register
            //`REG_P7PKTIN_ADDR : begin
            //    reg_data_out [`REG_P7PKTIN_BITS] =  p7_pktin;
            //end
            ////Pktout Register
            //`REG_P7PKTOUT_ADDR : begin
            //    reg_data_out [`REG_P7PKTOUT_BITS] =  p7_pktout;
            //end
            ////Pktin Register
            //`REG_P8PKTIN_ADDR : begin
            //    reg_data_out [`REG_P8PKTIN_BITS] =  p8_pktin;
            //end
            ////Pktout Register
            //`REG_P8PKTOUT_ADDR : begin
            //    reg_data_out [`REG_P8PKTOUT_BITS] =  p8_pktout;
            //end
            ////Pktin Register
            //`REG_P9PKTIN_ADDR : begin
            //    reg_data_out [`REG_P9PKTIN_BITS] =  p9_pktin;
            //end
            ////Pktout Register
            //`REG_P9PKTOUT_ADDR : begin
            //    reg_data_out [`REG_P9PKTOUT_BITS] =  p9_pktout;
            //end
            ////Pktin Register
            //`REG_P10PKTIN_ADDR : begin
            //    reg_data_out [`REG_P10PKTIN_BITS] =  p10_pktin;
            //end
            ////Pktout Register
            //`REG_P10PKTOUT_ADDR : begin
            //    reg_data_out [`REG_P10PKTOUT_BITS] =  p10_pktout;
            //end
            ////Pktin Register
            //`REG_P11PKTIN_ADDR : begin
            //    reg_data_out [`REG_P11PKTIN_BITS] =  p11_pktin;
            //end
            ////Pktout Register
            //`REG_P11PKTOUT_ADDR : begin
            //    reg_data_out [`REG_P11PKTOUT_BITS] =  p11_pktout;
            //end
            ////Pktin Register
            //`REG_P12PKTIN_ADDR : begin
            //    reg_data_out [`REG_P12PKTIN_BITS] =  p12_pktin;
            //end
            ////Pktout Register
            //`REG_P12PKTOUT_ADDR : begin
            //    reg_data_out [`REG_P12PKTOUT_BITS] =  p12_pktout;
            //end
            ////Pktin Register
            //`REG_P13PKTIN_ADDR : begin
            //    reg_data_out [`REG_P13PKTIN_BITS] =  p13_pktin;
            //end
            ////Pktout Register
            //`REG_P13PKTOUT_ADDR : begin
            //    reg_data_out [`REG_P13PKTOUT_BITS] =  p13_pktout;
            //end
            ////Pktin Register
            //`REG_P14PKTIN_ADDR : begin
            //    reg_data_out [`REG_P14PKTIN_BITS] =  p14_pktin;
            //end
            ////Pktout Register
            //`REG_P14PKTOUT_ADDR : begin
            //    reg_data_out [`REG_P14PKTOUT_BITS] =  p14_pktout;
            //end
            ////Pktin Register
            //`REG_P15PKTIN_ADDR : begin
            //    reg_data_out [`REG_P15PKTIN_BITS] =  p15_pktin;
            //end
            ////Pktout Register
            //`REG_P15PKTOUT_ADDR : begin
            //    reg_data_out [`REG_P15PKTOUT_BITS] =  p15_pktout;
            //end
            //Default return value
            default: begin
                reg_data_out [31:0] =  32'hDEADBEEF;
            end

        endcase

    end//end of assigning data to IP2Bus_Data bus

    //Read only registers, not cleared
    //Nothing to do here....

//Read only registers, cleared on read (e.g. counters)
    always @(posedge clk)
    if (!resetn_sync) begin
        pktin_reg_clear <= #1 1'b0;
        pktin_reg_clear_d <= #1 1'b0;
        pktout_reg_clear <= #1 1'b0;
        pktout_reg_clear_d <= #1 1'b0;
        querieshit_reg_clear <=  #1 1'b0;
        querieshit_reg_clear_d <=  #1 1'b0;
        queriesmiss_reg_clear <=  #1 1'b0;
        queriesmiss_reg_clear_d <=  #1 1'b0;
    end
    else begin
        pktin_reg_clear <= #1 pktin_reg_clear_d;
        pktin_reg_clear_d <= #1(reg_rden && (axi_araddr==`REG_PKTIN_ADDR)) ? 1'b1 : 1'b0;
        pktout_reg_clear <= #1 pktout_reg_clear_d;
        pktout_reg_clear_d <= #1(reg_rden && (axi_araddr==`REG_PKTOUT_ADDR)) ? 1'b1 : 1'b0;
        querieshit_reg_clear <= #1 querieshit_reg_clear_d;
        querieshit_reg_clear_d <= #1(reg_rden && (axi_araddr==`REG_L1HIT_ADDR)) ? 1'b1 : 1'b0;
        queriesmiss_reg_clear <= #1 querieshit_reg_clear_d;
        queriesmiss_reg_clear_d <= #1(reg_rden && (axi_araddr==`REG_L1MISS_ADDR)) ? 1'b1 : 1'b0;
    end


// Output register or memory read data
    always @( posedge S_AXI_ACLK )
    begin
      if ( S_AXI_ARESETN == 1'b0 )
        begin
          axi_rdata  <= 0;
        end
      else
        begin
          // When there is a valid read address (S_AXI_ARVALID) with
          // acceptance of read address by the slave (axi_arready),
          // output the read dada
          if (reg_rden)
            begin
              axi_rdata <= reg_data_out/*ip2bus_data*/;     // register read data /* some new changes here */
            end
        end
    end
endmodule
