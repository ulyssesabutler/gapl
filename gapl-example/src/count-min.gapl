interface pair<T, U> {
    first: T;
    second: U;
}

interface boolean wire

interface valid<T> {
    value: T;
    valid: boolean;
}

interface last<T> {
    value: T;
    last: boolean;
}

interface count wire[8]

interface sketch_column(
    // The number of possible values each has function can produce
    hash_function_depth: integer,
) count[hash_function_depth]

// TODO: Something that would be cool? A datatype that represents the number of bits need to store a value of at least size N.
interface sketch_column_index wire[4]

interface sketch(
    // The number of hash functions we need support
    hash_function_count: integer,
    // The number of possible values each has function can produce
    hash_function_depth: integer,
) sketch_column(hash_function_depth)[hash_function_count]

interface sketch3(hash_function_depth: integer) sketch(3, hash_function_depth)
interface sketch6(hash_function_depth: integer) sketch(6, hash_function_depth)

function count_min_vector_zip<I, J>(
    vector_size: integer,
) i1: I[vector_size], i2: J[vector_size] => o: pair<I, J>[vector_size] {
    i1[0] => o[0].first;
    i2[0] => o[0].second;

    if (vector_size > 1) {
        i1[1:vector_size - 1], i2[1:vector_size - 1]
            => count_min_vector_zip<I, J>(vector_size - 1)
            => o[1:vector_size - 1];
    }
}

function count_min_combinational_vector_fold<T, U>(
    size: integer,
    operation: T, U => U,
) i: T[size], init: U => o: U {
    if (size == 1) {
        i[0], init => operation => o;
    } else {
        i[0], init => operation => declare updated_state: U;
        i[1:size - 1], updated_state => count_min_combinational_vector_fold<T, U>(size - 1, operation) => o;
    }
}

function count_min_vector_map<I, O>(
    size: integer,
    operation: I => O,
) i: I[size] => o: O[size] {
    if (size > 0) {
        i[size - 1] => operation => o[size - 1];

        if (size > 1) {
            i[0:size - 2] => count_min_vector_map<I, O>(size - 1, operation) => o[0:size - 2];
        }
    }
}

function count_min_generate_index_list(size: integer) null => o: sketch_column_index[size] {
    literal(4, size - 1) => o[size - 1];

    if (size > 1) {
        declare recursivefun: count_min_generate_index_list(size - 1) => o[0:size - 2];
    }
}

function count_min_replicate<I>(factor: integer) i: I => o: I[factor] {
    i => o[0];
    if (factor > 1) {
        i => count_min_replicate<I>(factor - 1) => o[1:factor - 1];
    }
}

function count_min_unpair<T, U, V>(
    operation: T, U => V
) i: pair<T, U> => o: V {
    i.first, i.second => operation => o;
}

function count_min_vector_to_wire() i: wire[1] => o: wire { i[0] => o; }

function count_min_wire_to_vector() i: wire => o: wire[1] { i => o[0]; }

function count_min_left_pad(
    original: integer,
    padding: integer,
) i: wire[original] => o: wire[original + padding] {
    i => o[0:original - 1];
    literal(padding, 0) => o[original:original + padding - 1];
}

function count_min_boolean_to_int(size: integer) i: wire => o: wire[size] {
    i => count_min_wire_to_vector() => count_min_left_pad(1, size - 1) => o;
}

function count_min_fold<T, U>(
    replication_factor: integer,
    operation: T, U => U,
) i: last<T[replication_factor]> => o: valid<U> {
    declare state: register<U>();
    i.value, state
        => count_min_combinational_vector_fold<T, U>(replication_factor, operation)
        => state
        => o.value;

    i.last => register<boolean>() => o.valid;
}

function count_min_increment_sketch_column(
    depth: integer,
) index: sketch_column_index, original: sketch_column(depth) => updated: sketch_column(depth) {

    // First, let's generate the increment vector. This will be a vector where a single value is 1, all others are 0
    index => count_min_replicate<sketch_column_index>(depth) => declare replicated_index: sketch_column_index[depth];
    count_min_generate_index_list(depth) => declare index_list: sketch_column_index[depth];

    replicated_index, index_list
        => count_min_vector_zip<sketch_column_index, sketch_column_index>(depth)
        => count_min_vector_map<pair<sketch_column_index, sketch_column_index>, boolean>(
            depth,
            count_min_unpair<sketch_column_index, sketch_column_index, boolean>(equals(4)),
        )
        => count_min_vector_map<boolean, count>(depth, count_min_boolean_to_int(8))
        => declare increment_vector: sketch_column(depth);

    // Now, let's add the increment vector to the input column
    original, increment_vector
        => count_min_vector_zip<count, count>(depth)
        => count_min_vector_map<pair<count, count>, count>(
            depth,
            count_min_unpair<count, count, count>(add(8))
        )
        => updated;

}

function hash_with_op(op: wire[4], wire[4] => wire[4]) i: wire[8] => o: wire[4] {
    i[0:3], i[4:7] => op => o;
}

function count_min_int_hash0() i: wire[8] => o: sketch_column_index {
    i => hash_with_op(bitwise_xor(4)) => o;
}

function count_min_int_hash1() i: wire[8] => o: sketch_column_index {
    i => hash_with_op(add(4)) => o;
}

function count_min_int_hash2() i: wire[8] => o: sketch_column_index {
    i => hash_with_op(multiply(4)) => o;
}

function count_min_update_sketch3<T>(
    depth: integer,
    hash0: T => sketch_column_index,
    hash1: T => sketch_column_index,
    hash2: T => sketch_column_index,
) value: T, original: sketch3(depth) => updated: sketch3(depth) {

    // Run the hash functions on the input
    value => hash0 => declare hash0_index: sketch_column_index;
    value => hash1 => declare hash1_index: sketch_column_index;
    value => hash2 => declare hash2_index: sketch_column_index;

    // Now, using the results of the hash functions to update the sketch
    hash0_index, original[0] => count_min_increment_sketch_column(depth) => updated[0];
    hash1_index, original[1] => count_min_increment_sketch_column(depth) => updated[1];
    hash2_index, original[2] => count_min_increment_sketch_column(depth) => updated[2];

}

function count_min_update_sketch6<T>(
    depth: integer,
    hash0: T => sketch_column_index,
    hash1: T => sketch_column_index,
    hash2: T => sketch_column_index,
    hash3: T => sketch_column_index,
    hash4: T => sketch_column_index,
    hash5: T => sketch_column_index,
) value: T, original: sketch6(depth) => updated: sketch6(depth) {

    // Run the hash functions on the input
    value => hash0 => declare hash0_index: sketch_column_index;
    value => hash1 => declare hash1_index: sketch_column_index;
    value => hash2 => declare hash2_index: sketch_column_index;
    value => hash3 => declare hash3_index: sketch_column_index;
    value => hash4 => declare hash4_index: sketch_column_index;
    value => hash5 => declare hash5_index: sketch_column_index;

    // Now, using the results of the hash functions to update the sketch
    hash0_index, original[0] => count_min_increment_sketch_column(depth) => updated[0];
    hash1_index, original[1] => count_min_increment_sketch_column(depth) => updated[1];
    hash2_index, original[2] => count_min_increment_sketch_column(depth) => updated[2];
    hash3_index, original[3] => count_min_increment_sketch_column(depth) => updated[3];
    hash4_index, original[4] => count_min_increment_sketch_column(depth) => updated[4];
    hash5_index, original[5] => count_min_increment_sketch_column(depth) => updated[5];

}

function count_min_main() i: last<wire[8][3]> => o: valid<sketch3(16)> {
    i
        => count_min_fold<wire[8], sketch3(16)>(
            3,
            count_min_update_sketch3<wire[8]>(
                16,
                count_min_int_hash0,
                count_min_int_hash1,
                count_min_int_hash2,
            ),
        )
        => declare updated_state: valid<sketch3(16)>;

    // updated_state.value[0][0][0:7] => o.value;
    updated_state.value => o.value;
    updated_state.valid => o.valid;
}