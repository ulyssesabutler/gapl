// An alias interface
interface byte wire[8]

// An alias with a generic and a parameter
interface array(T: interface, size: integer) T[size]

// A record interface
interface pair {
    first: wire;
    second: wire;
}

// A nested interface
interface protocol {
    data1: wire;
    data2: wire[10];
    data3: pair[8][10];
}

function accessors() i: protocol => o: protocol {
    // This is a basic record accessor
    i.data1 => o.data1;

    // This is a single item vector accessor
    i.data2[9] => o.data2[9];

    // This is a slice accessor, both the start and end indices are inclusive.
    i.data2[0:8] => o.data2[0:8]; // Slice of length 9

    // Nested accessors
    i.data3[0][0].first => o.data3[0][0].first;
    i.data3[0][0].second => o.data3[0][0].second;
    i.data3[0][1:7] => o.data3[0][1:7];
    i.data3[1:9] => o.data3[1:9];
}

function predefined_functions() i: wire => o: wire {
    declare booleanvliteral: literal(1, 0);
    booleanvliteral[0] => declare booleanvalue: wire;

    booleanvalue => declare a: wire;
    booleanvalue => declare b: wire;

    // The literal function just produces a value. It produces a vector of wires.
    // The first value indicates the width of the vector, the second indicates the value on those wires.
    declare xliteralnode: literal(8, 5) => declare x: wire[8];
    declare yliteralnode: literal(8, 10) => declare y: wire[8];

    // Registers can also be created using a function. It can store values from any interface.
    declare register_in: wire => declare registernode: register(wire) => declare register_out: wire;

    booleanvalue => register_in;

    // Comparators take two arrays and return a wire
    x, y => equals(8) => declare equals_result: wire;
    x, y => not_equals(8) => declare not_equals_result: wire;
    x, y => less_than_equals(8) => declare less_than_equals_result: wire;
    x, y => greater_than_equals(8) => declare greater_than_equals_result: wire;

    // Binary operations take two wires and return a wire
    a, b => and() => declare and_result: wire;
    a, b => or() => declare or_result: wire;

    // Finally, all other operations accept and produce arrays of equal size
    x, y => add(8) => declare add_result: wire[8];
    x, y => subtract(8) => declare subtract_result: wire[8];
    x, y => multiply(8) => declare multiply_result: wire[8];
    x, y => left_shift(8) => declare left_shift_result: wire[8];
    x, y => right_shift(8) => declare right_shift_result: wire[8];

    and_result => o;
}

// This is a function that takes another function as a parameter
function functional_example(op: wire, wire => wire) i1: wire, i2: wire => o: wire {
    // The "function" keyword is still required
    i1, i2 => op => o;
}

function another_functional_example() i1: wire, i2: wire => o: wire {
    // Function parameter are passed using the same syntax to invoke the function
    i1, i2 => functional_example(and()) => o;
}